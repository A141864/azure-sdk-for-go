// Package speechservices implements the Azure ARM Speechservices service API version v2.0.
//
// Speech Services API v2.0.
package speechservices

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"github.com/satori/go.uuid"
	"io"
	"net/http"
)

const (
	// DefaultBaseURI is the default URI used for the service Speechservices
	DefaultBaseURI = "https://westus.cris.ai"
)

// BaseClient is the base client for Speechservices.
type BaseClient struct {
	autorest.Client
	BaseURI string
}

// New creates an instance of the BaseClient client.
func New() BaseClient {
	return NewWithBaseURI(DefaultBaseURI)
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string) BaseClient {
	return BaseClient{
		Client:  autorest.NewClientWithUserAgent(UserAgent()),
		BaseURI: baseURI,
	}
}

// CreateAccuracyTest sends the create accuracy test request.
// Parameters:
// testDefinition - the details of the new accuracy test.
func (client BaseClient) CreateAccuracyTest(ctx context.Context, testDefinition TestDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateAccuracyTest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: testDefinition,
			Constraints: []validation.Constraint{{Target: "testDefinition.Dataset", Name: validation.Null, Rule: true,
				Chain: []validation.Constraint{{Target: "testDefinition.Dataset.ID", Name: validation.Null, Rule: true, Chain: nil}}},
				{Target: "testDefinition.ModelsProperty", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "testDefinition.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateAccuracyTest", err.Error())
	}

	req, err := client.CreateAccuracyTestPreparer(ctx, testDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateAccuracyTest", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateAccuracyTestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateAccuracyTest", resp, "Failure sending request")
		return
	}

	result, err = client.CreateAccuracyTestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateAccuracyTest", resp, "Failure responding to request")
	}

	return
}

// CreateAccuracyTestPreparer prepares the CreateAccuracyTest request.
func (client BaseClient) CreateAccuracyTestPreparer(ctx context.Context, testDefinition TestDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/accuracytests"),
		autorest.WithJSON(testDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateAccuracyTestSender sends the CreateAccuracyTest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateAccuracyTestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateAccuracyTestResponder handles the response to the CreateAccuracyTest request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateAccuracyTestResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateEndpoint sends the create endpoint request.
// Parameters:
// endpointDefinition - the details of the endpoint.
func (client BaseClient) CreateEndpoint(ctx context.Context, endpointDefinition SpeechEndpointDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: endpointDefinition,
			Constraints: []validation.Constraint{{Target: "endpointDefinition.ConcurrentRecognitions", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "endpointDefinition.ConcurrentRecognitions", Name: validation.InclusiveMaximum, Rule: int64(20), Chain: nil},
					{Target: "endpointDefinition.ConcurrentRecognitions", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}},
				{Target: "endpointDefinition.ModelsProperty", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "endpointDefinition.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateEndpoint", err.Error())
	}

	req, err := client.CreateEndpointPreparer(ctx, endpointDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.CreateEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateEndpoint", resp, "Failure responding to request")
	}

	return
}

// CreateEndpointPreparer prepares the CreateEndpoint request.
func (client BaseClient) CreateEndpointPreparer(ctx context.Context, endpointDefinition SpeechEndpointDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/endpoints"),
		autorest.WithJSON(endpointDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateEndpointSender sends the CreateEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateEndpointResponder handles the response to the CreateEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateEndpointResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnsupportedMediaType, http.StatusTooManyRequests, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateEndpointDataExport sends the create endpoint data export request.
// Parameters:
// endpointID - the identifier of the endpoint.
// endpointDataDefinition - the details of the new endpoint data export.
func (client BaseClient) CreateEndpointDataExport(ctx context.Context, endpointID uuid.UUID, endpointDataDefinition EndpointDataDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateEndpointDataExport")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: endpointDataDefinition,
			Constraints: []validation.Constraint{{Target: "endpointDataDefinition.StartDate", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "endpointDataDefinition.EndDate", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateEndpointDataExport", err.Error())
	}

	req, err := client.CreateEndpointDataExportPreparer(ctx, endpointID, endpointDataDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateEndpointDataExport", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateEndpointDataExportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateEndpointDataExport", resp, "Failure sending request")
		return
	}

	result, err = client.CreateEndpointDataExportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateEndpointDataExport", resp, "Failure responding to request")
	}

	return
}

// CreateEndpointDataExportPreparer prepares the CreateEndpointDataExport request.
func (client BaseClient) CreateEndpointDataExportPreparer(ctx context.Context, endpointID uuid.UUID, endpointDataDefinition EndpointDataDefinition) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"endpointId": autorest.Encode("path", endpointID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{endpointId}/data", pathParameters),
		autorest.WithJSON(endpointDataDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateEndpointDataExportSender sends the CreateEndpointDataExport request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateEndpointDataExportSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateEndpointDataExportResponder handles the response to the CreateEndpointDataExport request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateEndpointDataExportResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateLanguageGenerationEndpoint sends the create language generation endpoint request.
func (client BaseClient) CreateLanguageGenerationEndpoint(ctx context.Context, endpointDefinition EndpointDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateLanguageGenerationEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: endpointDefinition,
			Constraints: []validation.Constraint{{Target: "endpointDefinition.ConcurrentRecognitions", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "endpointDefinition.ConcurrentRecognitions", Name: validation.InclusiveMaximum, Rule: int64(20), Chain: nil},
					{Target: "endpointDefinition.ConcurrentRecognitions", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}},
				{Target: "endpointDefinition.ModelsProperty", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "endpointDefinition.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateLanguageGenerationEndpoint", err.Error())
	}

	req, err := client.CreateLanguageGenerationEndpointPreparer(ctx, endpointDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateLanguageGenerationEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateLanguageGenerationEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateLanguageGenerationEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.CreateLanguageGenerationEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateLanguageGenerationEndpoint", resp, "Failure responding to request")
	}

	return
}

// CreateLanguageGenerationEndpointPreparer prepares the CreateLanguageGenerationEndpoint request.
func (client BaseClient) CreateLanguageGenerationEndpointPreparer(ctx context.Context, endpointDefinition EndpointDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/languagegeneration/v2.0/Endpoints"),
		autorest.WithJSON(endpointDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateLanguageGenerationEndpointSender sends the CreateLanguageGenerationEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateLanguageGenerationEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateLanguageGenerationEndpointResponder handles the response to the CreateLanguageGenerationEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateLanguageGenerationEndpointResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateLanguageGenerationModel sends the create language generation model request.
func (client BaseClient) CreateLanguageGenerationModel(ctx context.Context, modelDefinition ModelDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateLanguageGenerationModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: modelDefinition,
			Constraints: []validation.Constraint{{Target: "modelDefinition.BaseModel", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "modelDefinition.BaseModel.ID", Name: validation.Null, Rule: true, Chain: nil}}},
				{Target: "modelDefinition.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateLanguageGenerationModel", err.Error())
	}

	req, err := client.CreateLanguageGenerationModelPreparer(ctx, modelDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateLanguageGenerationModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateLanguageGenerationModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateLanguageGenerationModel", resp, "Failure sending request")
		return
	}

	result, err = client.CreateLanguageGenerationModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateLanguageGenerationModel", resp, "Failure responding to request")
	}

	return
}

// CreateLanguageGenerationModelPreparer prepares the CreateLanguageGenerationModel request.
func (client BaseClient) CreateLanguageGenerationModelPreparer(ctx context.Context, modelDefinition ModelDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/languagegeneration/v2.0/Models"),
		autorest.WithJSON(modelDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateLanguageGenerationModelSender sends the CreateLanguageGenerationModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateLanguageGenerationModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateLanguageGenerationModelResponder handles the response to the CreateLanguageGenerationModel request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateLanguageGenerationModelResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusNoContent, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateModel sends the create model request.
// Parameters:
// modelDefinition - the details of the new model.
func (client BaseClient) CreateModel(ctx context.Context, modelDefinition SpeechModelDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: modelDefinition,
			Constraints: []validation.Constraint{{Target: "modelDefinition.BaseModel", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "modelDefinition.BaseModel.ID", Name: validation.Null, Rule: true, Chain: nil}}},
				{Target: "modelDefinition.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateModel", err.Error())
	}

	req, err := client.CreateModelPreparer(ctx, modelDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateModel", resp, "Failure sending request")
		return
	}

	result, err = client.CreateModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateModel", resp, "Failure responding to request")
	}

	return
}

// CreateModelPreparer prepares the CreateModel request.
func (client BaseClient) CreateModelPreparer(ctx context.Context, modelDefinition SpeechModelDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/models"),
		autorest.WithJSON(modelDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateModelSender sends the CreateModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateModelResponder handles the response to the CreateModel request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateModelResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateTranscription sends the create transcription request.
// Parameters:
// transcription - the details of the new transcription.
func (client BaseClient) CreateTranscription(ctx context.Context, transcription TranscriptionDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateTranscription")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: transcription,
			Constraints: []validation.Constraint{{Target: "transcription.RecordingsURL", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "transcription.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateTranscription", err.Error())
	}

	req, err := client.CreateTranscriptionPreparer(ctx, transcription)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateTranscription", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateTranscriptionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateTranscription", resp, "Failure sending request")
		return
	}

	result, err = client.CreateTranscriptionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateTranscription", resp, "Failure responding to request")
	}

	return
}

// CreateTranscriptionPreparer prepares the CreateTranscription request.
func (client BaseClient) CreateTranscriptionPreparer(ctx context.Context, transcription TranscriptionDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/transcriptions"),
		autorest.WithJSON(transcription))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateTranscriptionSender sends the CreateTranscription request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateTranscriptionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateTranscriptionResponder handles the response to the CreateTranscription request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateTranscriptionResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnsupportedMediaType, http.StatusTooManyRequests, http.StatusServiceUnavailable),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateVoiceDeployment sends the create voice deployment request.
func (client BaseClient) CreateVoiceDeployment(ctx context.Context, endpoint EndpointDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateVoiceDeployment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: endpoint,
			Constraints: []validation.Constraint{{Target: "endpoint.ConcurrentRecognitions", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "endpoint.ConcurrentRecognitions", Name: validation.InclusiveMaximum, Rule: int64(20), Chain: nil},
					{Target: "endpoint.ConcurrentRecognitions", Name: validation.InclusiveMinimum, Rule: 1, Chain: nil},
				}},
				{Target: "endpoint.ModelsProperty", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "endpoint.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateVoiceDeployment", err.Error())
	}

	req, err := client.CreateVoiceDeploymentPreparer(ctx, endpoint)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateVoiceDeploymentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.CreateVoiceDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceDeployment", resp, "Failure responding to request")
	}

	return
}

// CreateVoiceDeploymentPreparer prepares the CreateVoiceDeployment request.
func (client BaseClient) CreateVoiceDeploymentPreparer(ctx context.Context, endpoint EndpointDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/endpoints"),
		autorest.WithJSON(endpoint))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateVoiceDeploymentSender sends the CreateVoiceDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateVoiceDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateVoiceDeploymentResponder handles the response to the CreateVoiceDeployment request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateVoiceDeploymentResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateVoiceModel sends the create voice model request.
func (client BaseClient) CreateVoiceModel(ctx context.Context, modelDefinition ModelDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateVoiceModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: modelDefinition,
			Constraints: []validation.Constraint{{Target: "modelDefinition.BaseModel", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "modelDefinition.BaseModel.ID", Name: validation.Null, Rule: true, Chain: nil}}},
				{Target: "modelDefinition.Name", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateVoiceModel", err.Error())
	}

	req, err := client.CreateVoiceModelPreparer(ctx, modelDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateVoiceModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceModel", resp, "Failure sending request")
		return
	}

	result, err = client.CreateVoiceModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceModel", resp, "Failure responding to request")
	}

	return
}

// CreateVoiceModelPreparer prepares the CreateVoiceModel request.
func (client BaseClient) CreateVoiceModelPreparer(ctx context.Context, modelDefinition ModelDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/models"),
		autorest.WithJSON(modelDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateVoiceModelSender sends the CreateVoiceModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateVoiceModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateVoiceModelResponder handles the response to the CreateVoiceModel request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateVoiceModelResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// CreateVoiceTest sends the create voice test request.
func (client BaseClient) CreateVoiceTest(ctx context.Context, voiceTestDefinition VoiceTestDefinition) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.CreateVoiceTest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: voiceTestDefinition,
			Constraints: []validation.Constraint{{Target: "voiceTestDefinition.Text", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "voiceTestDefinition.Model", Name: validation.Null, Rule: true,
					Chain: []validation.Constraint{{Target: "voiceTestDefinition.Model.ID", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("speechservices.BaseClient", "CreateVoiceTest", err.Error())
	}

	req, err := client.CreateVoiceTestPreparer(ctx, voiceTestDefinition)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceTest", nil, "Failure preparing request")
		return
	}

	resp, err := client.CreateVoiceTestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceTest", resp, "Failure sending request")
		return
	}

	result, err = client.CreateVoiceTestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "CreateVoiceTest", resp, "Failure responding to request")
	}

	return
}

// CreateVoiceTestPreparer prepares the CreateVoiceTest request.
func (client BaseClient) CreateVoiceTestPreparer(ctx context.Context, voiceTestDefinition VoiceTestDefinition) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/tests"),
		autorest.WithJSON(voiceTestDefinition))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// CreateVoiceTestSender sends the CreateVoiceTest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) CreateVoiceTestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// CreateVoiceTestResponder handles the response to the CreateVoiceTest request. The method always
// closes the http.Response Body.
func (client BaseClient) CreateVoiceTestResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteAccuracyTest sends the delete accuracy test request.
// Parameters:
// ID - the identifier of the accuracy test.
func (client BaseClient) DeleteAccuracyTest(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteAccuracyTest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteAccuracyTestPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteAccuracyTest", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteAccuracyTestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteAccuracyTest", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteAccuracyTestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteAccuracyTest", resp, "Failure responding to request")
	}

	return
}

// DeleteAccuracyTestPreparer prepares the DeleteAccuracyTest request.
func (client BaseClient) DeleteAccuracyTestPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/accuracytests/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteAccuracyTestSender sends the DeleteAccuracyTest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteAccuracyTestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteAccuracyTestResponder handles the response to the DeleteAccuracyTest request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteAccuracyTestResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteDataset sends the delete dataset request.
// Parameters:
// ID - the identifier of the dataset.
func (client BaseClient) DeleteDataset(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteDataset")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteDatasetPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteDataset", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDatasetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteDataset", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDatasetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteDataset", resp, "Failure responding to request")
	}

	return
}

// DeleteDatasetPreparer prepares the DeleteDataset request.
func (client BaseClient) DeleteDatasetPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/datasets/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDatasetSender sends the DeleteDataset request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteDatasetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteDatasetResponder handles the response to the DeleteDataset request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteDatasetResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteDeployment sends the delete deployment request.
// Parameters:
// ID - the id of voice endpoint.
func (client BaseClient) DeleteDeployment(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteDeployment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteDeploymentPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteDeploymentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteDeployment", resp, "Failure responding to request")
	}

	return
}

// DeleteDeploymentPreparer prepares the DeleteDeployment request.
func (client BaseClient) DeleteDeploymentPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/endpoints/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteDeploymentSender sends the DeleteDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteDeploymentResponder handles the response to the DeleteDeployment request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteDeploymentResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteEndpoint sends the delete endpoint request.
// Parameters:
// ID - the identifier of the endpoint.
func (client BaseClient) DeleteEndpoint(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteEndpointPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpoint", resp, "Failure responding to request")
	}

	return
}

// DeleteEndpointPreparer prepares the DeleteEndpoint request.
func (client BaseClient) DeleteEndpointPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteEndpointSender sends the DeleteEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteEndpointResponder handles the response to the DeleteEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteEndpointResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteEndpointData deletion will happen in the background and can take up to a day.
// Parameters:
// endpointID - the identifier of the endpoint.
func (client BaseClient) DeleteEndpointData(ctx context.Context, endpointID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteEndpointData")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteEndpointDataPreparer(ctx, endpointID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpointData", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteEndpointDataSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpointData", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteEndpointDataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpointData", resp, "Failure responding to request")
	}

	return
}

// DeleteEndpointDataPreparer prepares the DeleteEndpointData request.
func (client BaseClient) DeleteEndpointDataPreparer(ctx context.Context, endpointID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"endpointId": autorest.Encode("path", endpointID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{endpointId}/data", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteEndpointDataSender sends the DeleteEndpointData request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteEndpointDataSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteEndpointDataResponder handles the response to the DeleteEndpointData request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteEndpointDataResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteEndpointDataExport sends the delete endpoint data export request.
// Parameters:
// endpointID - the identifier of the endpoint.
// ID - the identifier of the endpoint data export.
func (client BaseClient) DeleteEndpointDataExport(ctx context.Context, endpointID uuid.UUID, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteEndpointDataExport")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteEndpointDataExportPreparer(ctx, endpointID, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpointDataExport", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteEndpointDataExportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpointDataExport", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteEndpointDataExportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteEndpointDataExport", resp, "Failure responding to request")
	}

	return
}

// DeleteEndpointDataExportPreparer prepares the DeleteEndpointDataExport request.
func (client BaseClient) DeleteEndpointDataExportPreparer(ctx context.Context, endpointID uuid.UUID, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"endpointId": autorest.Encode("path", endpointID),
		"id":         autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{endpointId}/data/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteEndpointDataExportSender sends the DeleteEndpointDataExport request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteEndpointDataExportSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteEndpointDataExportResponder handles the response to the DeleteEndpointDataExport request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteEndpointDataExportResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteLanguageGenerationEndpoint sends the delete language generation endpoint request.
// Parameters:
// ID - the identifier of the language generation model endpoint.
func (client BaseClient) DeleteLanguageGenerationEndpoint(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteLanguageGenerationEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteLanguageGenerationEndpointPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteLanguageGenerationEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteLanguageGenerationEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteLanguageGenerationEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteLanguageGenerationEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteLanguageGenerationEndpoint", resp, "Failure responding to request")
	}

	return
}

// DeleteLanguageGenerationEndpointPreparer prepares the DeleteLanguageGenerationEndpoint request.
func (client BaseClient) DeleteLanguageGenerationEndpointPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/languagegeneration/v2.0/Endpoints/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteLanguageGenerationEndpointSender sends the DeleteLanguageGenerationEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteLanguageGenerationEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteLanguageGenerationEndpointResponder handles the response to the DeleteLanguageGenerationEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteLanguageGenerationEndpointResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteLanguageGenerationModel sends the delete language generation model request.
// Parameters:
// ID - the identifier of the language generation model.
func (client BaseClient) DeleteLanguageGenerationModel(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteLanguageGenerationModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteLanguageGenerationModelPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteLanguageGenerationModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteLanguageGenerationModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteLanguageGenerationModel", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteLanguageGenerationModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteLanguageGenerationModel", resp, "Failure responding to request")
	}

	return
}

// DeleteLanguageGenerationModelPreparer prepares the DeleteLanguageGenerationModel request.
func (client BaseClient) DeleteLanguageGenerationModelPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/languagegeneration/v2.0/Models/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteLanguageGenerationModelSender sends the DeleteLanguageGenerationModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteLanguageGenerationModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteLanguageGenerationModelResponder handles the response to the DeleteLanguageGenerationModel request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteLanguageGenerationModelResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteModel sends the delete model request.
// Parameters:
// ID - the identifier of the model.
func (client BaseClient) DeleteModel(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteModelPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteModel", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteModel", resp, "Failure responding to request")
	}

	return
}

// DeleteModelPreparer prepares the DeleteModel request.
func (client BaseClient) DeleteModelPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/models/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteModelSender sends the DeleteModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteModelResponder handles the response to the DeleteModel request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteModelResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteTranscription sends the delete transcription request.
// Parameters:
// ID - the identifier of the transcription.
func (client BaseClient) DeleteTranscription(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteTranscription")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteTranscriptionPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteTranscription", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteTranscriptionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteTranscription", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteTranscriptionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteTranscription", resp, "Failure responding to request")
	}

	return
}

// DeleteTranscriptionPreparer prepares the DeleteTranscription request.
func (client BaseClient) DeleteTranscriptionPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/transcriptions/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteTranscriptionSender sends the DeleteTranscription request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteTranscriptionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteTranscriptionResponder handles the response to the DeleteTranscription request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteTranscriptionResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteVoiceDataset sends the delete voice dataset request.
// Parameters:
// ID - the identifier of the voice dataset
func (client BaseClient) DeleteVoiceDataset(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteVoiceDataset")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteVoiceDatasetPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceDataset", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteVoiceDatasetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceDataset", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteVoiceDatasetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceDataset", resp, "Failure responding to request")
	}

	return
}

// DeleteVoiceDatasetPreparer prepares the DeleteVoiceDataset request.
func (client BaseClient) DeleteVoiceDatasetPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/datasets/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteVoiceDatasetSender sends the DeleteVoiceDataset request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteVoiceDatasetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteVoiceDatasetResponder handles the response to the DeleteVoiceDataset request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteVoiceDatasetResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteVoiceModel sends the delete voice model request.
// Parameters:
// ID - the identifier of the voice model
func (client BaseClient) DeleteVoiceModel(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteVoiceModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteVoiceModelPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteVoiceModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceModel", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteVoiceModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceModel", resp, "Failure responding to request")
	}

	return
}

// DeleteVoiceModelPreparer prepares the DeleteVoiceModel request.
func (client BaseClient) DeleteVoiceModelPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/models/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteVoiceModelSender sends the DeleteVoiceModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteVoiceModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteVoiceModelResponder handles the response to the DeleteVoiceModel request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteVoiceModelResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// DeleteVoiceTest sends the delete voice test request.
// Parameters:
// ID - the identifier of the voice test.
func (client BaseClient) DeleteVoiceTest(ctx context.Context, ID uuid.UUID) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.DeleteVoiceTest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.DeleteVoiceTestPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceTest", nil, "Failure preparing request")
		return
	}

	resp, err := client.DeleteVoiceTestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceTest", resp, "Failure sending request")
		return
	}

	result, err = client.DeleteVoiceTestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "DeleteVoiceTest", resp, "Failure responding to request")
	}

	return
}

// DeleteVoiceTestPreparer prepares the DeleteVoiceTest request.
func (client BaseClient) DeleteVoiceTestPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/tests/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// DeleteVoiceTestSender sends the DeleteVoiceTest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) DeleteVoiceTestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// DeleteVoiceTestResponder handles the response to the DeleteVoiceTest request. The method always
// closes the http.Response Body.
func (client BaseClient) DeleteVoiceTestResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusNoContent, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusMethodNotAllowed, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAccuracyTest sends the get accuracy test request.
// Parameters:
// ID - the identifier of the accuracy test.
func (client BaseClient) GetAccuracyTest(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetAccuracyTest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetAccuracyTestPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetAccuracyTest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAccuracyTestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetAccuracyTest", resp, "Failure sending request")
		return
	}

	result, err = client.GetAccuracyTestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetAccuracyTest", resp, "Failure responding to request")
	}

	return
}

// GetAccuracyTestPreparer prepares the GetAccuracyTest request.
func (client BaseClient) GetAccuracyTestPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/accuracytests/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAccuracyTestSender sends the GetAccuracyTest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetAccuracyTestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetAccuracyTestResponder handles the response to the GetAccuracyTest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetAccuracyTestResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetAccuracyTests sends the get accuracy tests request.
func (client BaseClient) GetAccuracyTests(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetAccuracyTests")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetAccuracyTestsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetAccuracyTests", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetAccuracyTestsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetAccuracyTests", resp, "Failure sending request")
		return
	}

	result, err = client.GetAccuracyTestsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetAccuracyTests", resp, "Failure responding to request")
	}

	return
}

// GetAccuracyTestsPreparer prepares the GetAccuracyTests request.
func (client BaseClient) GetAccuracyTestsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/accuracytests"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetAccuracyTestsSender sends the GetAccuracyTests request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetAccuracyTestsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetAccuracyTestsResponder handles the response to the GetAccuracyTests request. The method always
// closes the http.Response Body.
func (client BaseClient) GetAccuracyTestsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDataset sends the get dataset request.
// Parameters:
// ID - the identifier of the dataset.
func (client BaseClient) GetDataset(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDataset")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDatasetPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetDataset", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDatasetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetDataset", resp, "Failure sending request")
		return
	}

	result, err = client.GetDatasetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetDataset", resp, "Failure responding to request")
	}

	return
}

// GetDatasetPreparer prepares the GetDataset request.
func (client BaseClient) GetDatasetPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/datasets/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDatasetSender sends the GetDataset request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDatasetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDatasetResponder handles the response to the GetDataset request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDatasetResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetDatasets sends the get datasets request.
func (client BaseClient) GetDatasets(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetDatasets")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetDatasetsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetDatasets", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetDatasetsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetDatasets", resp, "Failure sending request")
		return
	}

	result, err = client.GetDatasetsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetDatasets", resp, "Failure responding to request")
	}

	return
}

// GetDatasetsPreparer prepares the GetDatasets request.
func (client BaseClient) GetDatasetsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/datasets"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetDatasetsSender sends the GetDatasets request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetDatasetsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetDatasetsResponder handles the response to the GetDatasets request. The method always
// closes the http.Response Body.
func (client BaseClient) GetDatasetsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetEndpoint sends the get endpoint request.
// Parameters:
// ID - the identifier of the endpoint.
func (client BaseClient) GetEndpoint(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetEndpointPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.GetEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpoint", resp, "Failure responding to request")
	}

	return
}

// GetEndpointPreparer prepares the GetEndpoint request.
func (client BaseClient) GetEndpointPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetEndpointSender sends the GetEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetEndpointResponder handles the response to the GetEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) GetEndpointResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetEndpointDataExport sends the get endpoint data export request.
// Parameters:
// endpointID - the identifier of the endpoint.
// ID - the identifier of the data export.
func (client BaseClient) GetEndpointDataExport(ctx context.Context, endpointID uuid.UUID, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetEndpointDataExport")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetEndpointDataExportPreparer(ctx, endpointID, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpointDataExport", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetEndpointDataExportSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpointDataExport", resp, "Failure sending request")
		return
	}

	result, err = client.GetEndpointDataExportResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpointDataExport", resp, "Failure responding to request")
	}

	return
}

// GetEndpointDataExportPreparer prepares the GetEndpointDataExport request.
func (client BaseClient) GetEndpointDataExportPreparer(ctx context.Context, endpointID uuid.UUID, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"endpointId": autorest.Encode("path", endpointID),
		"id":         autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{endpointId}/data/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetEndpointDataExportSender sends the GetEndpointDataExport request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetEndpointDataExportSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetEndpointDataExportResponder handles the response to the GetEndpointDataExport request. The method always
// closes the http.Response Body.
func (client BaseClient) GetEndpointDataExportResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetEndpointDataExports sends the get endpoint data exports request.
// Parameters:
// endpointID - the identifier of the endpoint.
func (client BaseClient) GetEndpointDataExports(ctx context.Context, endpointID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetEndpointDataExports")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetEndpointDataExportsPreparer(ctx, endpointID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpointDataExports", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetEndpointDataExportsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpointDataExports", resp, "Failure sending request")
		return
	}

	result, err = client.GetEndpointDataExportsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpointDataExports", resp, "Failure responding to request")
	}

	return
}

// GetEndpointDataExportsPreparer prepares the GetEndpointDataExports request.
func (client BaseClient) GetEndpointDataExportsPreparer(ctx context.Context, endpointID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"endpointId": autorest.Encode("path", endpointID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{endpointId}/data", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetEndpointDataExportsSender sends the GetEndpointDataExports request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetEndpointDataExportsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetEndpointDataExportsResponder handles the response to the GetEndpointDataExports request. The method always
// closes the http.Response Body.
func (client BaseClient) GetEndpointDataExportsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetEndpoints sends the get endpoints request.
func (client BaseClient) GetEndpoints(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetEndpoints")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetEndpointsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpoints", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetEndpointsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpoints", resp, "Failure sending request")
		return
	}

	result, err = client.GetEndpointsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetEndpoints", resp, "Failure responding to request")
	}

	return
}

// GetEndpointsPreparer prepares the GetEndpoints request.
func (client BaseClient) GetEndpointsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/endpoints"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetEndpointsSender sends the GetEndpoints request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetEndpointsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetEndpointsResponder handles the response to the GetEndpoints request. The method always
// closes the http.Response Body.
func (client BaseClient) GetEndpointsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetHealthStatus sends the get health status request.
func (client BaseClient) GetHealthStatus(ctx context.Context) (result HealthStatusResponse, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetHealthStatus")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetHealthStatusPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetHealthStatus", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetHealthStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetHealthStatus", resp, "Failure sending request")
		return
	}

	result, err = client.GetHealthStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetHealthStatus", resp, "Failure responding to request")
	}

	return
}

// GetHealthStatusPreparer prepares the GetHealthStatus request.
func (client BaseClient) GetHealthStatusPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/common/v2.0/healthstatus"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetHealthStatusSender sends the GetHealthStatus request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetHealthStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetHealthStatusResponder handles the response to the GetHealthStatus request. The method always
// closes the http.Response Body.
func (client BaseClient) GetHealthStatusResponder(resp *http.Response) (result HealthStatusResponse, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetLanguageGenerationEndpoint sends the get language generation endpoint request.
func (client BaseClient) GetLanguageGenerationEndpoint(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetLanguageGenerationEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetLanguageGenerationEndpointPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetLanguageGenerationEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.GetLanguageGenerationEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationEndpoint", resp, "Failure responding to request")
	}

	return
}

// GetLanguageGenerationEndpointPreparer prepares the GetLanguageGenerationEndpoint request.
func (client BaseClient) GetLanguageGenerationEndpointPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/languagegeneration/v2.0/Endpoints/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetLanguageGenerationEndpointSender sends the GetLanguageGenerationEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetLanguageGenerationEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetLanguageGenerationEndpointResponder handles the response to the GetLanguageGenerationEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) GetLanguageGenerationEndpointResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetLanguageGenerationEndpoints sends the get language generation endpoints request.
func (client BaseClient) GetLanguageGenerationEndpoints(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetLanguageGenerationEndpoints")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetLanguageGenerationEndpointsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationEndpoints", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetLanguageGenerationEndpointsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationEndpoints", resp, "Failure sending request")
		return
	}

	result, err = client.GetLanguageGenerationEndpointsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationEndpoints", resp, "Failure responding to request")
	}

	return
}

// GetLanguageGenerationEndpointsPreparer prepares the GetLanguageGenerationEndpoints request.
func (client BaseClient) GetLanguageGenerationEndpointsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/languagegeneration/v2.0/Endpoints"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetLanguageGenerationEndpointsSender sends the GetLanguageGenerationEndpoints request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetLanguageGenerationEndpointsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetLanguageGenerationEndpointsResponder handles the response to the GetLanguageGenerationEndpoints request. The method always
// closes the http.Response Body.
func (client BaseClient) GetLanguageGenerationEndpointsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetLanguageGenerationModel sends the get language generation model request.
func (client BaseClient) GetLanguageGenerationModel(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetLanguageGenerationModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetLanguageGenerationModelPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetLanguageGenerationModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationModel", resp, "Failure sending request")
		return
	}

	result, err = client.GetLanguageGenerationModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationModel", resp, "Failure responding to request")
	}

	return
}

// GetLanguageGenerationModelPreparer prepares the GetLanguageGenerationModel request.
func (client BaseClient) GetLanguageGenerationModelPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/languagegeneration/v2.0/Models/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetLanguageGenerationModelSender sends the GetLanguageGenerationModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetLanguageGenerationModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetLanguageGenerationModelResponder handles the response to the GetLanguageGenerationModel request. The method always
// closes the http.Response Body.
func (client BaseClient) GetLanguageGenerationModelResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetLanguageGenerationModels sends the get language generation models request.
func (client BaseClient) GetLanguageGenerationModels(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetLanguageGenerationModels")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetLanguageGenerationModelsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationModels", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetLanguageGenerationModelsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationModels", resp, "Failure sending request")
		return
	}

	result, err = client.GetLanguageGenerationModelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetLanguageGenerationModels", resp, "Failure responding to request")
	}

	return
}

// GetLanguageGenerationModelsPreparer prepares the GetLanguageGenerationModels request.
func (client BaseClient) GetLanguageGenerationModelsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/languagegeneration/v2.0/Models"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetLanguageGenerationModelsSender sends the GetLanguageGenerationModels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetLanguageGenerationModelsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetLanguageGenerationModelsResponder handles the response to the GetLanguageGenerationModels request. The method always
// closes the http.Response Body.
func (client BaseClient) GetLanguageGenerationModelsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetModel sends the get model request.
// Parameters:
// ID - the identifier of the model.
func (client BaseClient) GetModel(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetModelPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetModel", resp, "Failure sending request")
		return
	}

	result, err = client.GetModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetModel", resp, "Failure responding to request")
	}

	return
}

// GetModelPreparer prepares the GetModel request.
func (client BaseClient) GetModelPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/models/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModelSender sends the GetModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModelResponder handles the response to the GetModel request. The method always
// closes the http.Response Body.
func (client BaseClient) GetModelResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetModels sends the get models request.
func (client BaseClient) GetModels(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetModels")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetModelsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetModels", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetModelsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetModels", resp, "Failure sending request")
		return
	}

	result, err = client.GetModelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetModels", resp, "Failure responding to request")
	}

	return
}

// GetModelsPreparer prepares the GetModels request.
func (client BaseClient) GetModelsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/models"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetModelsSender sends the GetModels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetModelsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetModelsResponder handles the response to the GetModels request. The method always
// closes the http.Response Body.
func (client BaseClient) GetModelsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForDatasets sends the get supported locales for datasets request.
func (client BaseClient) GetSupportedLocalesForDatasets(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForDatasets")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForDatasetsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForDatasets", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForDatasetsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForDatasets", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForDatasetsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForDatasets", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForDatasetsPreparer prepares the GetSupportedLocalesForDatasets request.
func (client BaseClient) GetSupportedLocalesForDatasetsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/datasets/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForDatasetsSender sends the GetSupportedLocalesForDatasets request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForDatasetsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForDatasetsResponder handles the response to the GetSupportedLocalesForDatasets request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForDatasetsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForEndpoints sends the get supported locales for endpoints request.
func (client BaseClient) GetSupportedLocalesForEndpoints(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForEndpoints")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForEndpointsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForEndpoints", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForEndpointsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForEndpoints", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForEndpointsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForEndpoints", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForEndpointsPreparer prepares the GetSupportedLocalesForEndpoints request.
func (client BaseClient) GetSupportedLocalesForEndpointsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/endpoints/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForEndpointsSender sends the GetSupportedLocalesForEndpoints request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForEndpointsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForEndpointsResponder handles the response to the GetSupportedLocalesForEndpoints request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForEndpointsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForLanguageGenerationEndpoints sends the get supported locales for language generation endpoints
// request.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationEndpoints(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForLanguageGenerationEndpoints")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForLanguageGenerationEndpointsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForLanguageGenerationEndpoints", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForLanguageGenerationEndpointsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForLanguageGenerationEndpoints", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForLanguageGenerationEndpointsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForLanguageGenerationEndpoints", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForLanguageGenerationEndpointsPreparer prepares the GetSupportedLocalesForLanguageGenerationEndpoints request.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationEndpointsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/languagegeneration/v2.0/Endpoints/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForLanguageGenerationEndpointsSender sends the GetSupportedLocalesForLanguageGenerationEndpoints request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationEndpointsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForLanguageGenerationEndpointsResponder handles the response to the GetSupportedLocalesForLanguageGenerationEndpoints request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationEndpointsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForLanguageGenerationModels sends the get supported locales for language generation models
// request.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationModels(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForLanguageGenerationModels")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForLanguageGenerationModelsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForLanguageGenerationModels", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForLanguageGenerationModelsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForLanguageGenerationModels", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForLanguageGenerationModelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForLanguageGenerationModels", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForLanguageGenerationModelsPreparer prepares the GetSupportedLocalesForLanguageGenerationModels request.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationModelsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/languagegeneration/v2.0/Models/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForLanguageGenerationModelsSender sends the GetSupportedLocalesForLanguageGenerationModels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationModelsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForLanguageGenerationModelsResponder handles the response to the GetSupportedLocalesForLanguageGenerationModels request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForLanguageGenerationModelsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForModels sends the get supported locales for models request.
func (client BaseClient) GetSupportedLocalesForModels(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForModels")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForModelsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForModels", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForModelsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForModels", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForModelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForModels", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForModelsPreparer prepares the GetSupportedLocalesForModels request.
func (client BaseClient) GetSupportedLocalesForModelsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/models/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForModelsSender sends the GetSupportedLocalesForModels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForModelsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForModelsResponder handles the response to the GetSupportedLocalesForModels request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForModelsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForTranscriptions sends the get supported locales for transcriptions request.
func (client BaseClient) GetSupportedLocalesForTranscriptions(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForTranscriptions")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForTranscriptionsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForTranscriptions", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForTranscriptionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForTranscriptions", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForTranscriptionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForTranscriptions", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForTranscriptionsPreparer prepares the GetSupportedLocalesForTranscriptions request.
func (client BaseClient) GetSupportedLocalesForTranscriptionsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/transcriptions/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForTranscriptionsSender sends the GetSupportedLocalesForTranscriptions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForTranscriptionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForTranscriptionsResponder handles the response to the GetSupportedLocalesForTranscriptions request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForTranscriptionsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForVoiceDatasets sends the get supported locales for voice datasets request.
func (client BaseClient) GetSupportedLocalesForVoiceDatasets(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForVoiceDatasets")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForVoiceDatasetsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceDatasets", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForVoiceDatasetsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceDatasets", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForVoiceDatasetsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceDatasets", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForVoiceDatasetsPreparer prepares the GetSupportedLocalesForVoiceDatasets request.
func (client BaseClient) GetSupportedLocalesForVoiceDatasetsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/datasets/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForVoiceDatasetsSender sends the GetSupportedLocalesForVoiceDatasets request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForVoiceDatasetsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForVoiceDatasetsResponder handles the response to the GetSupportedLocalesForVoiceDatasets request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForVoiceDatasetsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForVoiceEndpoints sends the get supported locales for voice endpoints request.
func (client BaseClient) GetSupportedLocalesForVoiceEndpoints(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForVoiceEndpoints")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForVoiceEndpointsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceEndpoints", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForVoiceEndpointsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceEndpoints", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForVoiceEndpointsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceEndpoints", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForVoiceEndpointsPreparer prepares the GetSupportedLocalesForVoiceEndpoints request.
func (client BaseClient) GetSupportedLocalesForVoiceEndpointsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/endpoints/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForVoiceEndpointsSender sends the GetSupportedLocalesForVoiceEndpoints request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForVoiceEndpointsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForVoiceEndpointsResponder handles the response to the GetSupportedLocalesForVoiceEndpoints request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForVoiceEndpointsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetSupportedLocalesForVoiceModels sends the get supported locales for voice models request.
func (client BaseClient) GetSupportedLocalesForVoiceModels(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetSupportedLocalesForVoiceModels")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetSupportedLocalesForVoiceModelsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceModels", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetSupportedLocalesForVoiceModelsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceModels", resp, "Failure sending request")
		return
	}

	result, err = client.GetSupportedLocalesForVoiceModelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetSupportedLocalesForVoiceModels", resp, "Failure responding to request")
	}

	return
}

// GetSupportedLocalesForVoiceModelsPreparer prepares the GetSupportedLocalesForVoiceModels request.
func (client BaseClient) GetSupportedLocalesForVoiceModelsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/models/locales"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetSupportedLocalesForVoiceModelsSender sends the GetSupportedLocalesForVoiceModels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetSupportedLocalesForVoiceModelsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetSupportedLocalesForVoiceModelsResponder handles the response to the GetSupportedLocalesForVoiceModels request. The method always
// closes the http.Response Body.
func (client BaseClient) GetSupportedLocalesForVoiceModelsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTranscription sends the get transcription request.
// Parameters:
// ID - the identifier of the transcription.
func (client BaseClient) GetTranscription(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetTranscription")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetTranscriptionPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetTranscription", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTranscriptionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetTranscription", resp, "Failure sending request")
		return
	}

	result, err = client.GetTranscriptionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetTranscription", resp, "Failure responding to request")
	}

	return
}

// GetTranscriptionPreparer prepares the GetTranscription request.
func (client BaseClient) GetTranscriptionPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/transcriptions/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTranscriptionSender sends the GetTranscription request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetTranscriptionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTranscriptionResponder handles the response to the GetTranscription request. The method always
// closes the http.Response Body.
func (client BaseClient) GetTranscriptionResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusNotFound, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetTranscriptions sends the get transcriptions request.
func (client BaseClient) GetTranscriptions(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetTranscriptions")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetTranscriptionsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetTranscriptions", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetTranscriptionsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetTranscriptions", resp, "Failure sending request")
		return
	}

	result, err = client.GetTranscriptionsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetTranscriptions", resp, "Failure responding to request")
	}

	return
}

// GetTranscriptionsPreparer prepares the GetTranscriptions request.
func (client BaseClient) GetTranscriptionsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/transcriptions"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetTranscriptionsSender sends the GetTranscriptions request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetTranscriptionsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetTranscriptionsResponder handles the response to the GetTranscriptions request. The method always
// closes the http.Response Body.
func (client BaseClient) GetTranscriptionsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVoiceDatasets sends the get voice datasets request.
func (client BaseClient) GetVoiceDatasets(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetVoiceDatasets")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetVoiceDatasetsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDatasets", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVoiceDatasetsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDatasets", resp, "Failure sending request")
		return
	}

	result, err = client.GetVoiceDatasetsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDatasets", resp, "Failure responding to request")
	}

	return
}

// GetVoiceDatasetsPreparer prepares the GetVoiceDatasets request.
func (client BaseClient) GetVoiceDatasetsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/datasets"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVoiceDatasetsSender sends the GetVoiceDatasets request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetVoiceDatasetsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetVoiceDatasetsResponder handles the response to the GetVoiceDatasets request. The method always
// closes the http.Response Body.
func (client BaseClient) GetVoiceDatasetsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVoiceDeployment sends the get voice deployment request.
func (client BaseClient) GetVoiceDeployment(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetVoiceDeployment")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetVoiceDeploymentPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDeployment", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVoiceDeploymentSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDeployment", resp, "Failure sending request")
		return
	}

	result, err = client.GetVoiceDeploymentResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDeployment", resp, "Failure responding to request")
	}

	return
}

// GetVoiceDeploymentPreparer prepares the GetVoiceDeployment request.
func (client BaseClient) GetVoiceDeploymentPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/endpoints/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVoiceDeploymentSender sends the GetVoiceDeployment request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetVoiceDeploymentSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetVoiceDeploymentResponder handles the response to the GetVoiceDeployment request. The method always
// closes the http.Response Body.
func (client BaseClient) GetVoiceDeploymentResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVoiceDeployments sends the get voice deployments request.
func (client BaseClient) GetVoiceDeployments(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetVoiceDeployments")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetVoiceDeploymentsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDeployments", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVoiceDeploymentsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDeployments", resp, "Failure sending request")
		return
	}

	result, err = client.GetVoiceDeploymentsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceDeployments", resp, "Failure responding to request")
	}

	return
}

// GetVoiceDeploymentsPreparer prepares the GetVoiceDeployments request.
func (client BaseClient) GetVoiceDeploymentsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/endpoints"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVoiceDeploymentsSender sends the GetVoiceDeployments request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetVoiceDeploymentsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetVoiceDeploymentsResponder handles the response to the GetVoiceDeployments request. The method always
// closes the http.Response Body.
func (client BaseClient) GetVoiceDeploymentsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVoiceModel sends the get voice model request.
func (client BaseClient) GetVoiceModel(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetVoiceModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetVoiceModelPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVoiceModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceModel", resp, "Failure sending request")
		return
	}

	result, err = client.GetVoiceModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceModel", resp, "Failure responding to request")
	}

	return
}

// GetVoiceModelPreparer prepares the GetVoiceModel request.
func (client BaseClient) GetVoiceModelPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/models/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVoiceModelSender sends the GetVoiceModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetVoiceModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetVoiceModelResponder handles the response to the GetVoiceModel request. The method always
// closes the http.Response Body.
func (client BaseClient) GetVoiceModelResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVoiceModels sends the get voice models request.
func (client BaseClient) GetVoiceModels(ctx context.Context) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetVoiceModels")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetVoiceModelsPreparer(ctx)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceModels", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVoiceModelsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceModels", resp, "Failure sending request")
		return
	}

	result, err = client.GetVoiceModelsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceModels", resp, "Failure responding to request")
	}

	return
}

// GetVoiceModelsPreparer prepares the GetVoiceModels request.
func (client BaseClient) GetVoiceModelsPreparer(ctx context.Context) (*http.Request, error) {
	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/models"))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVoiceModelsSender sends the GetVoiceModels request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetVoiceModelsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetVoiceModelsResponder handles the response to the GetVoiceModels request. The method always
// closes the http.Response Body.
func (client BaseClient) GetVoiceModelsResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetVoiceTest sends the get voice test request.
// Parameters:
// ID - the identifier of the voice test.
func (client BaseClient) GetVoiceTest(ctx context.Context, ID uuid.UUID) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.GetVoiceTest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.GetVoiceTestPreparer(ctx, ID)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceTest", nil, "Failure preparing request")
		return
	}

	resp, err := client.GetVoiceTestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceTest", resp, "Failure sending request")
		return
	}

	result, err = client.GetVoiceTestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "GetVoiceTest", resp, "Failure responding to request")
	}

	return
}

// GetVoiceTestPreparer prepares the GetVoiceTest request.
func (client BaseClient) GetVoiceTestPreparer(ctx context.Context, ID uuid.UUID) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/tests/{id}", pathParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// GetVoiceTestSender sends the GetVoiceTest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) GetVoiceTestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// GetVoiceTestResponder handles the response to the GetVoiceTest request. The method always
// closes the http.Response Body.
func (client BaseClient) GetVoiceTestResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusUnauthorized, http.StatusForbidden, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateAccuracyTest sends the update accuracy test request.
// Parameters:
// ID - the identifier of the accuracy test.
// testUpdate - the object containing the updated fields of the test.
func (client BaseClient) UpdateAccuracyTest(ctx context.Context, ID uuid.UUID, testUpdate TestUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateAccuracyTest")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateAccuracyTestPreparer(ctx, ID, testUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateAccuracyTest", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateAccuracyTestSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateAccuracyTest", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateAccuracyTestResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateAccuracyTest", resp, "Failure responding to request")
	}

	return
}

// UpdateAccuracyTestPreparer prepares the UpdateAccuracyTest request.
func (client BaseClient) UpdateAccuracyTestPreparer(ctx context.Context, ID uuid.UUID, testUpdate TestUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/accuracytests/{id}", pathParameters),
		autorest.WithJSON(testUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateAccuracyTestSender sends the UpdateAccuracyTest request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateAccuracyTestSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateAccuracyTestResponder handles the response to the UpdateAccuracyTest request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateAccuracyTestResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateDataset sends the update dataset request.
// Parameters:
// ID - the identifier of the dataset.
// datasetUpdate - the updated values for the dataset.
func (client BaseClient) UpdateDataset(ctx context.Context, ID uuid.UUID, datasetUpdate DatasetUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateDataset")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateDatasetPreparer(ctx, ID, datasetUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateDataset", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateDatasetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateDataset", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateDatasetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateDataset", resp, "Failure responding to request")
	}

	return
}

// UpdateDatasetPreparer prepares the UpdateDataset request.
func (client BaseClient) UpdateDatasetPreparer(ctx context.Context, ID uuid.UUID, datasetUpdate DatasetUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/datasets/{id}", pathParameters),
		autorest.WithJSON(datasetUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateDatasetSender sends the UpdateDataset request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateDatasetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateDatasetResponder handles the response to the UpdateDataset request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateDatasetResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateEndpoint sends the update endpoint request.
// Parameters:
// ID - the identifier of the endpoint.
// endpointUpdate - the updated values for the endpoint.
func (client BaseClient) UpdateEndpoint(ctx context.Context, ID uuid.UUID, endpointUpdate EndpointUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateEndpointPreparer(ctx, ID, endpointUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateEndpoint", resp, "Failure responding to request")
	}

	return
}

// UpdateEndpointPreparer prepares the UpdateEndpoint request.
func (client BaseClient) UpdateEndpointPreparer(ctx context.Context, ID uuid.UUID, endpointUpdate EndpointUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/endpoints/{id}", pathParameters),
		autorest.WithJSON(endpointUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateEndpointSender sends the UpdateEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateEndpointResponder handles the response to the UpdateEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateEndpointResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateLanguageGenerationEndpoint sends the update language generation endpoint request.
// Parameters:
// ID - the identifier of the language generation model endpoint.
// endpointUpdate - the object contains the updated fields of the endpoint.
func (client BaseClient) UpdateLanguageGenerationEndpoint(ctx context.Context, ID uuid.UUID, endpointUpdate EndpointUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateLanguageGenerationEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateLanguageGenerationEndpointPreparer(ctx, ID, endpointUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateLanguageGenerationEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateLanguageGenerationEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateLanguageGenerationEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateLanguageGenerationEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateLanguageGenerationEndpoint", resp, "Failure responding to request")
	}

	return
}

// UpdateLanguageGenerationEndpointPreparer prepares the UpdateLanguageGenerationEndpoint request.
func (client BaseClient) UpdateLanguageGenerationEndpointPreparer(ctx context.Context, ID uuid.UUID, endpointUpdate EndpointUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/languagegeneration/v2.0/Endpoints/{id}", pathParameters),
		autorest.WithJSON(endpointUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateLanguageGenerationEndpointSender sends the UpdateLanguageGenerationEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateLanguageGenerationEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateLanguageGenerationEndpointResponder handles the response to the UpdateLanguageGenerationEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateLanguageGenerationEndpointResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateLanguageGenerationModel sends the update language generation model request.
// Parameters:
// ID - the route parameter identifies the language generation model to change.
// modelUpdate - the object contains the updated fields of the model.
func (client BaseClient) UpdateLanguageGenerationModel(ctx context.Context, ID uuid.UUID, modelUpdate ModelUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateLanguageGenerationModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateLanguageGenerationModelPreparer(ctx, ID, modelUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateLanguageGenerationModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateLanguageGenerationModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateLanguageGenerationModel", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateLanguageGenerationModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateLanguageGenerationModel", resp, "Failure responding to request")
	}

	return
}

// UpdateLanguageGenerationModelPreparer prepares the UpdateLanguageGenerationModel request.
func (client BaseClient) UpdateLanguageGenerationModelPreparer(ctx context.Context, ID uuid.UUID, modelUpdate ModelUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/languagegeneration/v2.0/Models/{id}", pathParameters),
		autorest.WithJSON(modelUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateLanguageGenerationModelSender sends the UpdateLanguageGenerationModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateLanguageGenerationModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateLanguageGenerationModelResponder handles the response to the UpdateLanguageGenerationModel request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateLanguageGenerationModelResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateModel sends the update model request.
// Parameters:
// ID - the identifier of the model.
// modelUpdate - the updated values for the model.
func (client BaseClient) UpdateModel(ctx context.Context, ID uuid.UUID, modelUpdate ModelUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateModelPreparer(ctx, ID, modelUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateModel", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateModel", resp, "Failure responding to request")
	}

	return
}

// UpdateModelPreparer prepares the UpdateModel request.
func (client BaseClient) UpdateModelPreparer(ctx context.Context, ID uuid.UUID, modelUpdate ModelUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/models/{id}", pathParameters),
		autorest.WithJSON(modelUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateModelSender sends the UpdateModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateModelResponder handles the response to the UpdateModel request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateModelResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateTranscription sends the update transcription request.
// Parameters:
// ID - the identifier of the transcription.
// transcriptionUpdate - the updated values for the transcription.
func (client BaseClient) UpdateTranscription(ctx context.Context, ID uuid.UUID, transcriptionUpdate TranscriptionUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateTranscription")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateTranscriptionPreparer(ctx, ID, transcriptionUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateTranscription", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateTranscriptionSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateTranscription", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateTranscriptionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateTranscription", resp, "Failure responding to request")
	}

	return
}

// UpdateTranscriptionPreparer prepares the UpdateTranscription request.
func (client BaseClient) UpdateTranscriptionPreparer(ctx context.Context, ID uuid.UUID, transcriptionUpdate TranscriptionUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/speechtotext/v2.0/transcriptions/{id}", pathParameters),
		autorest.WithJSON(transcriptionUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateTranscriptionSender sends the UpdateTranscription request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateTranscriptionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateTranscriptionResponder handles the response to the UpdateTranscription request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateTranscriptionResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVoiceDataset sends the update voice dataset request.
// Parameters:
// ID - the identifier of the voice dataset.
// datasetUpdate - the updated values for the voice dataset.
func (client BaseClient) UpdateVoiceDataset(ctx context.Context, ID uuid.UUID, datasetUpdate DatasetUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateVoiceDataset")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateVoiceDatasetPreparer(ctx, ID, datasetUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceDataset", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateVoiceDatasetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceDataset", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateVoiceDatasetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceDataset", resp, "Failure responding to request")
	}

	return
}

// UpdateVoiceDatasetPreparer prepares the UpdateVoiceDataset request.
func (client BaseClient) UpdateVoiceDatasetPreparer(ctx context.Context, ID uuid.UUID, datasetUpdate DatasetUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/datasets/{id}", pathParameters),
		autorest.WithJSON(datasetUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVoiceDatasetSender sends the UpdateVoiceDataset request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateVoiceDatasetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateVoiceDatasetResponder handles the response to the UpdateVoiceDataset request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateVoiceDatasetResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVoiceEndpoint sends the update voice endpoint request.
// Parameters:
// ID - the identifier of the endpoint.
// endpointUpdate - the updated values for the endpoint.
func (client BaseClient) UpdateVoiceEndpoint(ctx context.Context, ID uuid.UUID, endpointUpdate EndpointUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateVoiceEndpoint")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateVoiceEndpointPreparer(ctx, ID, endpointUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceEndpoint", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateVoiceEndpointSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceEndpoint", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateVoiceEndpointResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceEndpoint", resp, "Failure responding to request")
	}

	return
}

// UpdateVoiceEndpointPreparer prepares the UpdateVoiceEndpoint request.
func (client BaseClient) UpdateVoiceEndpointPreparer(ctx context.Context, ID uuid.UUID, endpointUpdate EndpointUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/endpoints/{id}", pathParameters),
		autorest.WithJSON(endpointUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVoiceEndpointSender sends the UpdateVoiceEndpoint request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateVoiceEndpointSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateVoiceEndpointResponder handles the response to the UpdateVoiceEndpoint request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateVoiceEndpointResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UpdateVoiceModel sends the update voice model request.
// Parameters:
// ID - the identifier of the voice model.
// modelUpdate - the updated values for the voice model.
func (client BaseClient) UpdateVoiceModel(ctx context.Context, ID uuid.UUID, modelUpdate ModelUpdate) (result SetObject, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UpdateVoiceModel")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UpdateVoiceModelPreparer(ctx, ID, modelUpdate)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceModel", nil, "Failure preparing request")
		return
	}

	resp, err := client.UpdateVoiceModelSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceModel", resp, "Failure sending request")
		return
	}

	result, err = client.UpdateVoiceModelResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UpdateVoiceModel", resp, "Failure responding to request")
	}

	return
}

// UpdateVoiceModelPreparer prepares the UpdateVoiceModel request.
func (client BaseClient) UpdateVoiceModelPreparer(ctx context.Context, ID uuid.UUID, modelUpdate ModelUpdate) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"id": autorest.Encode("path", ID),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPatch(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/api/texttospeech/v2.0/models/{id}", pathParameters),
		autorest.WithJSON(modelUpdate))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UpdateVoiceModelSender sends the UpdateVoiceModel request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UpdateVoiceModelSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UpdateVoiceModelResponder handles the response to the UpdateVoiceModel request. The method always
// closes the http.Response Body.
func (client BaseClient) UpdateVoiceModelResponder(resp *http.Response) (result SetObject, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusConflict, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result.Value),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UploadDataset sends the upload dataset request.
// Parameters:
// name - the name of this data import (always add this string for any import).
// description - optional description of this data import.
// locale - the locale of this data import (always add this string for any import).
// dataImportKind - the kind of the data import (always add this string for any import).
// properties - optional properties of this data import (json serialized object with key/values, where all
// values must be strings)
// audiodata - a zip file containing the audio data (this and the audio archive file for acoustic data
// imports).
// transcriptions - a text file containing the transcriptions for the audio data (this and the transcriptions
// file for acoustic data imports).
// languagedata - a text file containing the language or pronunciation data (only this file for language data
// imports).
func (client BaseClient) UploadDataset(ctx context.Context, name string, description string, locale string, dataImportKind string, properties string, audiodata io.ReadCloser, transcriptions io.ReadCloser, languagedata io.ReadCloser) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UploadDataset")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UploadDatasetPreparer(ctx, name, description, locale, dataImportKind, properties, audiodata, transcriptions, languagedata)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UploadDataset", nil, "Failure preparing request")
		return
	}

	resp, err := client.UploadDatasetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UploadDataset", resp, "Failure sending request")
		return
	}

	result, err = client.UploadDatasetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UploadDataset", resp, "Failure responding to request")
	}

	return
}

// UploadDatasetPreparer prepares the UploadDataset request.
func (client BaseClient) UploadDatasetPreparer(ctx context.Context, name string, description string, locale string, dataImportKind string, properties string, audiodata io.ReadCloser, transcriptions io.ReadCloser, languagedata io.ReadCloser) (*http.Request, error) {
	formDataParameters := map[string]interface{}{}
	if len(name) > 0 {
		formDataParameters["name"] = name
	}
	if len(description) > 0 {
		formDataParameters["description"] = description
	}
	if len(locale) > 0 {
		formDataParameters["locale"] = locale
	}
	if len(string(dataImportKind)) > 0 {
		formDataParameters["dataImportKind"] = dataImportKind
	}
	if len(properties) > 0 {
		formDataParameters["properties"] = properties
	}
	if audiodata != nil {
		formDataParameters["audiodata"] = audiodata
	}
	if transcriptions != nil {
		formDataParameters["transcriptions"] = transcriptions
	}
	if languagedata != nil {
		formDataParameters["languagedata"] = languagedata
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/speechtotext/v2.0/datasets/upload"),
		autorest.WithMultiPartFormData(formDataParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UploadDatasetSender sends the UploadDataset request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UploadDatasetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UploadDatasetResponder handles the response to the UploadDataset request. The method always
// closes the http.Response Body.
func (client BaseClient) UploadDatasetResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// UploadVoiceDataset sends the upload voice dataset request.
// Parameters:
// name - the name of this data import (always add this string for any import).
// description - optional description of this data import.
// locale - the locale of this data import (always add this string for any import).
// dataImportKind - the kind of the data import (always add this string for any import).
// properties - optional properties of this data import (json serialized object with key/values, where all
// values must be strings)
// audiodata - a zip file containing the audio data.
// transcriptions - the transcriptions text file of the audio data.
func (client BaseClient) UploadVoiceDataset(ctx context.Context, name string, description string, locale string, dataImportKind string, properties string, audiodata io.ReadCloser, transcriptions io.ReadCloser) (result ErrorContent, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/BaseClient.UploadVoiceDataset")
		defer func() {
			sc := -1
			if result.Response.Response != nil {
				sc = result.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	req, err := client.UploadVoiceDatasetPreparer(ctx, name, description, locale, dataImportKind, properties, audiodata, transcriptions)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UploadVoiceDataset", nil, "Failure preparing request")
		return
	}

	resp, err := client.UploadVoiceDatasetSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UploadVoiceDataset", resp, "Failure sending request")
		return
	}

	result, err = client.UploadVoiceDatasetResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "speechservices.BaseClient", "UploadVoiceDataset", resp, "Failure responding to request")
	}

	return
}

// UploadVoiceDatasetPreparer prepares the UploadVoiceDataset request.
func (client BaseClient) UploadVoiceDatasetPreparer(ctx context.Context, name string, description string, locale string, dataImportKind string, properties string, audiodata io.ReadCloser, transcriptions io.ReadCloser) (*http.Request, error) {
	formDataParameters := map[string]interface{}{}
	if len(name) > 0 {
		formDataParameters["name"] = name
	}
	if len(description) > 0 {
		formDataParameters["description"] = description
	}
	if len(locale) > 0 {
		formDataParameters["locale"] = locale
	}
	if len(string(dataImportKind)) > 0 {
		formDataParameters["dataImportKind"] = dataImportKind
	}
	if len(properties) > 0 {
		formDataParameters["properties"] = properties
	}
	if audiodata != nil {
		formDataParameters["audiodata"] = audiodata
	}
	if transcriptions != nil {
		formDataParameters["transcriptions"] = transcriptions
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPath("/api/texttospeech/v2.0/datasets/upload"),
		autorest.WithMultiPartFormData(formDataParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// UploadVoiceDatasetSender sends the UploadVoiceDataset request. The method will close the
// http.Response Body if it receives an error.
func (client BaseClient) UploadVoiceDatasetSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req,
		autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
}

// UploadVoiceDatasetResponder handles the response to the UploadVoiceDataset request. The method always
// closes the http.Response Body.
func (client BaseClient) UploadVoiceDatasetResponder(resp *http.Response) (result ErrorContent, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusAccepted, http.StatusBadRequest, http.StatusUnauthorized, http.StatusForbidden, http.StatusUnsupportedMediaType, http.StatusTooManyRequests),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}
